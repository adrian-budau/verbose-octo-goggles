# Basics

To run the given program you can either pass the transaction file as the first argument:

```
cargo run -- transactions.csv > accounts.csv
```

or pipe it to stdin to the program, also passing the `--` argument to signal this:

```
./get_transactions_somehow | cargo run -- -- > accounts.csv
```

# Completeness

The program handles all cases, including disputes, resolutions and chargebacks.
Disputes to withdrawals are logged because the client probably already has recieved the funds.

Errors generated by transactions are written to standard output, parsing errors are considered fatal, 
but any other error is only informative and will allow further execution.

The task was unclear on whether or not a client A is allowed to dispute client B's transactions.
This is by default **NOT** allowed, but can be enabled by changing the engine config `global_dispute`.
To do this change line `33` in `src/main.rs` from `engine.set_global_dispute(false)` 
to `engine.set_global_dispute(true)`;

# Correctness

## Sample 

There is a sample `transactions.csv` inside the repo with a small example showing 
all 5 types of transactions.

## Tests

There are some unit tests in src/engine.rs, they can easily be run with the default 
test runner:

```
cargo test
```

They try to test most common behavior, but also edge cases such as

* reusing the same transaction id across different clients
* ending up in negative balance because of a disputed deposit

# Safety and Robustness

There is no use of unsafe in the code and all the logic is wrapper inside the library with a 
custom error code. The only place the errors are handled and/or ignored is in the main program
where they either fatally stop the program or just get printed to standard error, or in the 
tests where they are unwrapped as a form of assertion.

The code assumes the input data is mostly correct, and that amount are not too large.
The data type used to hold balances and amounts is `Decimal` from the `rust_decimal` crate
which can hold values between $-2^{96}$ and $2^{96} - 1$. For comparison the total number of Satoshi
that will ever exist is $21 * 10^{14}$ which is roughly under $2^{51}$.

# Efficiency

The program is written to not read the whole file on input, but to process it with a buffered reader
thanks to the `csv` crate `Reader` which implementes buffering underneath. It also allows for the input to come from 
stdin so it can easily be piped from a different program (or `socat` from the network).
Even the output is buffered by the same reasons.

All access to information is kept behind hash maps, currently the `std::collections::HashMap`,
but this could easily be swapped later for a different data structure should the worst-case reallocation performance
be too slow for the business requirements.

It is unclear if resolved transactions can be under dispute again so all transactions are permanently kept in memory
in case they will be put under dispute. If this is not the case this can easily be changed, which would free some memory in
cases with millions or more transactions.

If memory is a bottleneck (for example because transactions number in the billions) a LRU cache could be kept on them, or a cache on the
last **X** transactions, while the others are persisted to the local filesystem, or just directly kept in a database.

This could easily be done with `SQLite`, but for a small performance and code complexity cost which I deemed
unnecessary at the moment.

# Maintainability

The code is nicely formatted using `rustfmt` and checked for (obvious) mistakes using `clippy`.
I've strived to have clear variables/method names.

There is also a `Wrapper` to help write tests easier by removing the need to remember transactions ids.
